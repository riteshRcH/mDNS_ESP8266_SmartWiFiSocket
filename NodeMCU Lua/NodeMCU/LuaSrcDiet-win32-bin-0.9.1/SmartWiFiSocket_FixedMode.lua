collectgarbage()require"SmartWiFiSocket_CommonUtils"local srv=nil local is_any_timer_running=false local running_timer_type=nil local running_timer_end_time=0 local running_timer_cron_mask_config_string=nil local running_timer_obj_ref=nil local running_timer_obj_type=nil
local cron_scheduled_after_sntp=false local fd=file.open('initial_setup_done','r')local _,_,_,timezone_offset_or_zone_filename_indicator,timezone_offset_or_zone_filename=fd:read():find('^(.)(.)(.+)$')fd:close()local internet_mode_configured_by=nil local external_wifi_ssid=nil fd=file.open("internet_mode_configured",'r')if fd then internet_mode_configured_by=fd:read()fd:close()end fd=file.open("mdns_hostname",'r')local mdns_hostname=fd:read()fd:close()fd=file.open('version','r')local socketSoftwareVersion=fd:read()fd:close()local stop_running_timer_and_set_desired_state=function(desired_state)if is_any_timer_running and running_timer_obj_ref then if running_timer_obj_type then running_timer_obj_ref:unschedule()else running_timer_obj_ref:stop()end is_any_timer_running=false end;(desired_state=='1'and set_gpio_relay_pin or reset_gpio_relay_pin)(false);return"success"end local tmrSyncStateWithCloudForInternetMode=tmr.create()tmrSyncStateWithCloudForInternetMode:register(660000,tmr.ALARM_AUTO,function(timer)http.get("http://pastebin.com/raw/EYQQsda5",nil,function(http_status_code,http_response)if http_status_code==200 then local _,_,cipher_text_len,cipher_text=http_response:find('([0-9]+)\r\n(.*)')local domain_name_and_rest_api_version=crypto.decrypt("AES-CBC","Pw4DoMAiNnAmE92$",encoder.fromBase64(cipher_text),"IVFoRAESCBCYo92&"):match("(.-)%z*$"):sub(1,cipher_text_len)if string.len(domain_name_and_rest_api_version)==tonumber(cipher_text_len)then domain_name_and_rest_api_version=domain_name_and_rest_api_version:match("^%s*(.-)%s*$")get_url=domain_name_and_rest_api_version..'/sockets_per_user_status?email='..encoder.toHex(internet_mode_configured_by)..'&socket_name='..mdns_hostname:gsub(' ','+')..'&external_wifi_ssid='..encoder.toHex(external_wifi_ssid)..'&source=socket'http.get(get_url,nil,function(code,data)if code==200 and data then local _,_,cipher_data_len,iv,cipher_data=data:find('([0-9]+)\r\n(................)(.*)')if not iv:find('[^0-9dfhjlnprtvxzEGIKNOQSUWY]')then local desired_state=crypto.decrypt("AES-CBC","PwSeRVeRdAta#92*",encoder.fromHex(cipher_data),iv):match("(.-)%z*$"):sub(1,cipher_data_len):match("^%s*(.-)%s*$"):match('^([0-9])$')if desired_state then stop_running_timer_and_set_desired_state(desired_state=='1')end end local iv2=''for i=1,16,1 do iv2=iv2..string.char(node.random(65,90))end current_rtctime=rtctime.get()http.put(domain_name_and_rest_api_version..'/sockets_per_user',nil,iv2..encoder.toHex(crypto.encrypt("AES-CBC","PwS0cKEtDaTA!92$",internet_mode_configured_by..'~'..mdns_hostname..'~'..external_wifi_ssid..'~'..(is_any_timer_running and(get_gpio_relay_pin_status()==1 and"2"or"3")or get_gpio_relay_pin_status())..'~'..current_rtctime..'~'..timezone_offset_or_zone_filename_indicator..timezone_offset_or_zone_filename..'~socket'..(is_any_timer_running and('~'..running_timer_type.."~"..running_timer_cron_mask_config_string.."~"..(running_timer_end_time-current_rtctime))or"").."~"..socketSoftwareVersion,iv2)),function(http_put_status_code,http_put_response)end)end end)end end collectgarbage()end)end)collectgarbage()local toggleTriColorRed=false local tmrBlinkTriColorRed=tmr.create()tmrBlinkTriColorRed:register(500,tmr.ALARM_AUTO,function(timer)toggleTriColorRed=not toggleTriColorRed gpio_write_setup_led_pins(toggleTriColorRed,false,false)end)local cron_fn_set_gpio_relay_pin=function(e)set_gpio_relay_pin(false)end local cron_fn_reset_gpio_relay_pin=function(e)reset_gpio_relay_pin(false)end
local url_decode=function(s)return s:gsub("+"," "):gsub("%%(%x%x)",function(h)return string.char(tonumber(h,16))end):gsub("\r\n","\n")end local append_line_to_file=function(line,filename,require_newline_char_after_line)local write_success_indicator=false local fh=file.open(filename,"a+")if fh then write_success_indicator=fh:write(line..(require_newline_char_after_line and"\n"or''))fh:close()end return write_success_indicator end local cron_schedule_OSCT_OSFT_RT_end_time=function(timer_duration_secs,before_state)local running_timer_expire_function=before_state=='1'and function(e)is_any_timer_running=false reset_gpio_relay_pin(false)end or function(e)is_any_timer_running=false set_gpio_relay_pin(false)end
running_timer_obj_type=timer_duration_secs>6870 if running_timer_obj_type then rtc_tbl=rtctime.epoch2cal(running_timer_end_time)running_timer_obj_ref=cron.schedule(rtc_tbl['min']..' '..rtc_tbl['hour']..' '..rtc_tbl['day']..' '..rtc_tbl['mon']..' *',running_timer_expire_function)rtc_tbl=nil else running_timer_obj_ref=tmr.create()running_timer_obj_ref:alarm(timer_duration_secs*1000,tmr.ALARM_SINGLE,running_timer_expire_function)end running_timer_expire_function=nil
end local cron_schedule_timer=function(cron_mask,before_state,timer_duration_secs,osft_or_rt,cron_mask_config_string)do before_state_in_use=before_state timer_duration_secs_in_use=timer_duration_secs osft_or_rt_in_use=osft_or_rt cron_mask_config_string_in_use=cron_mask_config_string function schedule_callback(e)(before_state_in_use=='1'and set_gpio_relay_pin or reset_gpio_relay_pin)(true);is_any_timer_running=true running_timer_type=osft_or_rt_in_use running_timer_cron_mask_config_string=cron_mask_config_string current_rtctime=rtctime.get()if current_rtctime>0 then running_timer_end_time=current_rtctime+timer_duration_secs
cron_schedule_OSCT_OSFT_RT_end_time(timer_duration_secs,before_state_in_use)end end end cron.schedule(cron_mask,schedule_callback)end local remove_all_date_files=function(except_date)for past_daily_schedule_timer_filename,_ in pairs(file.list())do if past_daily_schedule_timer_filename:find('^_')and past_daily_schedule_timer_filename~=except_date then file.remove(past_daily_schedule_timer_filename)end end end local identify_and_schedule_todays_schedule_timer_entries=function()cron.reset()current_rtctime=rtctime.get()today=tostring(rtctime.epoch2cal(current_rtctime)['wday']-1)tbl=rtctime.epoch2cal(current_rtctime)local todays_schedule_timers='_'..tbl['day']..tbl['mon']..tbl['year']remove_all_date_files(todays_schedule_timers)local was_todays_schedule_timers_present=file.exists(todays_schedule_timers)and file.list()[todays_schedule_timers]>0 fd=file.open(todays_schedule_timers,was_todays_schedule_timers_present and"r"or"w+")local todays_schedule_timers_contents=''if was_todays_schedule_timers_present then todays_schedule_timers_contents=fd:read()if not todays_schedule_timers_contents then todays_schedule_timers_contents=''end end fd:close()fd=file.open("OSFT",'r')while true do cron_mask_config_string=fd:readline()if cron_mask_config_string and cron_mask_config_string:find('^1')then cron_mask_config_string=cron_mask_config_string:match("^%s*(.-)%s*$")local _,_,cron_mask,in_year,before_state,timer_duration_secs,_=cron_mask_config_string:find('.([^=]+)=([^=]+)=(.)=([^=]+)=(.)')local _,_,min,hour,day,month=cron_mask:find('([^_]+)_([^_]+)_([^_]+)_([^_]+)_*')if tonumber(tbl['year'])==tonumber(in_year)and tonumber(tbl['mon'])==tonumber(month)and tonumber(tbl['day'])==tonumber(day)and((tonumber(tbl['hour'])==tonumber(hour)and tonumber(tbl['min'])<tonumber(min))or tonumber(tbl['hour'])<tonumber(hour))then if not was_todays_schedule_timers_present then append_line_to_file("1OSFT="..cron_mask_config_string,todays_schedule_timers,true)end if not was_todays_schedule_timers_present or todays_schedule_timers_contents:find("1OSFT="..cron_mask_config_string)then cron_schedule_timer(cron_mask:gsub('_',' '),before_state,tonumber(timer_duration_secs),"osft",cron_mask_config_string)end end else break end end fd:close()fd=file.open("FS",'r')while true do cron_mask_config_string=fd:readline()if cron_mask_config_string and cron_mask_config_string:find('^1')then cron_mask_config_string=cron_mask_config_string:match("^%s*(.-)%s*$")local _,_,cron_mask,in_year,desired_state=cron_mask_config_string:find('.([^=]+)=([^=]+)=(.)')local _,_,min,hour,day,month=cron_mask:find('([^_]+)_([^_]+)_([^_]+)_([^_]+)_*')if tonumber(tbl['year'])==tonumber(in_year)and tonumber(tbl['mon'])==tonumber(month)and tonumber(tbl['day'])==tonumber(day)and((tonumber(tbl['hour'])==tonumber(hour)and tonumber(tbl['min'])<tonumber(min))or tonumber(tbl['hour'])<tonumber(hour))then if not was_todays_schedule_timers_present then append_line_to_file("1FS="..cron_mask_config_string,todays_schedule_timers,true)end if not was_todays_schedule_timers_present or todays_schedule_timers_contents:find("1FS="..cron_mask_config_string)then cron.schedule(cron_mask:gsub('_',' '),desired_state=='1'and cron_fn_set_gpio_relay_pin or cron_fn_reset_gpio_relay_pin)end end else break end end fd:close()fd=file.open("RS",'r')while true do cron_mask_config_string=fd:readline()if cron_mask_config_string and cron_mask_config_string:find('^1')then cron_mask_config_string=cron_mask_config_string:match("^%s*(.-)%s*$")local _,_,cron_mask,recurrence_start,recurrence_end,desired_state=cron_mask_config_string:find('.([^=]+)=([^=]+)=([^=]+)=(.)')_,_,cron_mask_recurring_days=cron_mask:find('[^_]+_[^_]+_[^_]+_[^_]+_([^_]+)')recurrence_start=tonumber(recurrence_start)recurrence_end=tonumber(recurrence_end)if((recurrence_start==0 or recurrence_end==0)or(current_rtctime>recurrence_start and current_rtctime<recurrence_end))and(cron_mask_recurring_days=='*'or cron_mask_recurring_days:find(today))then if not was_todays_schedule_timers_present then append_line_to_file("1RS="..cron_mask_config_string,todays_schedule_timers,true)end if not was_todays_schedule_timers_present or todays_schedule_timers_contents:find("1RS="..cron_mask_config_string)then cron.schedule(cron_mask:gsub('_',' '),desired_state=='1'and cron_fn_set_gpio_relay_pin or cron_fn_reset_gpio_relay_pin)end end else break end end fd:close()fd=file.open("RT",'r')while true do cron_mask_config_string=fd:readline()if cron_mask_config_string and cron_mask_config_string:find('^1')then cron_mask_config_string=cron_mask_config_string:match("^%s*(.-)%s*$")local _,_,cron_mask,recurrence_start,recurrence_end,before_state,timer_duration_secs,_=cron_mask_config_string:find('.([^=]+)=([^=]+)=([^=]+)=(.)=([^=]+)=(.)')_,_,cron_mask_recurring_days=cron_mask:find('[^_]+_[^_]+_[^_]+_[^_]+_([^_]+)')recurrence_start=tonumber(recurrence_start)recurrence_end=tonumber(recurrence_end)if((recurrence_start==0 or recurrence_end==0)or(current_rtctime>recurrence_start and current_rtctime<recurrence_end))and(cron_mask_recurring_days=='*'or cron_mask_recurring_days:find(today))then if not was_todays_schedule_timers_present then append_line_to_file("1RT="..cron_mask_config_string,todays_schedule_timers,true)end if not was_todays_schedule_timers_present or todays_schedule_timers_contents:find("1RT="..cron_mask_config_string)then cron_schedule_timer(cron_mask:gsub('_',' '),before_state,tonumber(timer_duration_secs),"rt",cron_mask_config_string)end end else break end end fd:close()cron.schedule('02 0 * * *',function(e)if get_gpio_relay_pin_status()==1 then
file.open('restore_relay_on',"w+"):close()end
remove_all_date_files(nil)node.restart()end)cron_scheduled_after_sntp=true
gpio_write_setup_led_pins(not cron_scheduled_after_sntp,cron_scheduled_after_sntp,false)fd=nil collectgarbage()end local start_fixed_mode_web_server=function()collectgarbage()srv=net.createServer(net.TCP)if srv then srv:listen(9911,function(conn)conn:on("receive",function(client_conn,payload)local _,_,method,path,vars=payload:find("([A-Z]+) (.+)?(.+) HTTP")if(method==nil)then _,_,method,path=payload:find("([A-Z]+) (.+) HTTP")end client_conn:send("HTTP/1.1 200 OK\nContent-Type: text/plain\n\n")if method=='GET'then if path=='/gpio/relay_status'then current_rtctime=rtctime.get()client_conn:send((is_any_timer_running and(get_gpio_relay_pin_status()==1 and"2"or"3")or get_gpio_relay_pin_status())..((internet_mode_configured_by==nil and'0'or('1'..internet_mode_configured_by)).."~"..external_wifi_ssid..'~'..((current_rtctime==nil or current_rtctime==0)and"NA"or(timezone_offset_or_zone_filename_indicator..timezone_offset_or_zone_filename)))..(is_any_timer_running and('~'..running_timer_type..";"..running_timer_cron_mask_config_string..";"..(running_timer_end_time-current_rtctime))or"").."~"..socketSoftwareVersion)elseif path=='/gpio/relay/1'then client_conn:send(is_any_timer_running and"error"or(set_gpio_relay_pin(false)and"success"or"error"))elseif path=='/gpio/relay/0'then client_conn:send(is_any_timer_running and"error"or(reset_gpio_relay_pin(false)and"success"or"error"))elseif path=='/set_new_osct'then current_rtctime=rtctime.get()if current_rtctime>0 then if is_any_timer_running then client_conn:send("error_another_timer_running")else local _,_,cron_mask_config_string=vars:find('cron_mask_config_string=([^&]+)')cron_mask_config_string=url_decode(cron_mask_config_string)local _,_,before_state,timer_duration_secs,_=cron_mask_config_string:find('(.)=([^=]+)=(.)')timer_duration_secs=tonumber(timer_duration_secs);(before_state=='1'and set_gpio_relay_pin or reset_gpio_relay_pin)(true);is_any_timer_running=true running_timer_type="osct"running_timer_cron_mask_config_string=cron_mask_config_string running_timer_end_time=current_rtctime+timer_duration_secs
cron_schedule_OSCT_OSFT_RT_end_time(timer_duration_secs,before_state)client_conn:send("success")end else client_conn:send("error_no_rtc")end elseif path=='/get_schedule_timers'then local _,_,schedule_timer_filename=vars:find('schedule_timer_filename=([^&]+)')local fh=file.open(schedule_timer_filename,'r')if fh and(schedule_timer_filename=='OSFT'or schedule_timer_filename=='FS'or schedule_timer_filename=='RS'or schedule_timer_filename=='RT'or schedule_timer_filename:find('^_'))then local file_contents=fh:read()client_conn:send(file_contents==nil and"empty"or file_contents)fh:close()else client_conn:send("error")end elseif path=='/save_update_enabled_remove_schedule_timer_or_update_run_skip_for_today'then
local _,_,call_type=vars:find('call_type=([^&]+)')current_rtctime=rtctime.get()if current_rtctime>0 then if is_any_timer_running and call_type~='removing_past_entries'then client_conn:send("error_another_timer_running")else if get_gpio_relay_pin_status()==0 or call_type=='removing_past_entries'then local _,_,schedule_timer_filename=vars:find('schedule_timer_filename=([^&]+)')local _,_,cron_mask_config_string=vars:find('cron_mask_config_string=([^&]+)')local _,_,truncate_before_update=vars:find('truncate_before_update=([^&]+)')local _,_,last_run_skip_update_or_todays_entry_saved_updated_removed=vars:find('last_run_skip_update_or_todays_entry_saved_updated_removed=([^&]+)')local _,_,todays_schedule_timers=vars:find('todays_schedule_timers=([^&]+)')if truncate_before_update=='1'then file.open(schedule_timer_filename,"w+"):close()end if cron_mask_config_string then cron_mask_config_string=url_decode(cron_mask_config_string)end client_conn:send((cron_mask_config_string==nil or append_line_to_file(cron_mask_config_string,schedule_timer_filename,true))and"success"or"error")if last_run_skip_update_or_todays_entry_saved_updated_removed=='1'then if call_type=='remove_saved_schedule_timer'or call_type=='save_new_schedule_timer'or call_type=='update_enabled_schedule_timers'then file.remove(todays_schedule_timers)end
tmr.create():alarm(5000,tmr.ALARM_SINGLE,identify_and_schedule_todays_schedule_timer_entries)end else client_conn:send("allowed_only_when_appliance_off")end end else client_conn:send("error_no_rtc")end elseif path=='/gpio/relay/stop_running_timer'then local _,_,state_after_stopping_running_timer=vars:find('state_after_stopping_running_timer=([^&]+)')client_conn:send(stop_running_timer_and_set_desired_state(state_after_stopping_running_timer=='1'))elseif path=='/internet_mode_config'then local _,_,local_internet_mode_configured_by=vars:find('internet_mode_configured_by=([^&]+)')local_internet_mode_configured_by=url_decode(local_internet_mode_configured_by)if append_line_to_file(local_internet_mode_configured_by,"internet_mode_configured",false)then internet_mode_configured_by=local_internet_mode_configured_by tmrSyncStateWithCloudForInternetMode:start()client_conn:send("success")else client_conn:send("error")end else client_conn:send("error")end end end)conn:on("sent",function(client_conn)client_conn:close()collectgarbage()end)end)end end local internet_disconnected_handler=function()cron.reset()tmrSyncStateWithCloudForInternetMode:stop()cron_scheduled_after_sntp=false gpio_write_setup_led_pins(not cron_scheduled_after_sntp,cron_scheduled_after_sntp,false)end wifi.eventmon.register(wifi.eventmon.STA_GOT_IP,function(tbl_ip_params)tmrBlinkTriColorRed:stop()gpio_write_setup_led_pins(not cron_scheduled_after_sntp,cron_scheduled_after_sntp,false)external_wifi_ssid=wifi.sta.getconfig(true)['ssid']mdns.register(mdns_hostname,{service="http",port=9911})start_fixed_mode_web_server()sntp.sync(nil,function(sec)if timezone_offset_or_zone_filename_indicator=='0'then rtctime.set(sec+tonumber(timezone_offset_or_zone_filename))end gpio_write_setup_led_pins(not cron_scheduled_after_sntp,cron_scheduled_after_sntp,false)tmr.create():alarm(5000,tmr.ALARM_SINGLE,identify_and_schedule_todays_schedule_timer_entries)tmrSyncStateWithCloudForInternetMode:start()end,internet_disconnected_handler,1)end)wifi.eventmon.register(wifi.eventmon.STA_DISCONNECTED,function(tbl_disconnected_ap_details_and_reason)if srv then srv:close()srv=nil end mdns.close()internet_disconnected_handler()collectgarbage()gpio_write_setup_led_pins(false,false,false)tmrBlinkTriColorRed:start()wifi.sta.connect()end)gpio_write_setup_led_pins(false,false,false)tmrBlinkTriColorRed:start()wifi.sta.connect()